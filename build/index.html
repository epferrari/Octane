<html>

<head>
    <link type="text/css" rel="stylesheet" href="assets/css/_bower.css" />
    <link type="text/css" rel="stylesheet" href="assets/css/devdocs.css" />
    <link type="text/css" rel="stylesheet" href="assets/css/octane.css" />
</head>

<body class="container-fluid">
    <div class="row">
        <div class="col-sm-3 col-sm-push-9 hidden-xs" style="position:fixed">
            <div class="sidebar affix-top">
                <ul class="nav">
                    <li>
                        <a href="#overview">Overview</a>
                    </li>
                    <li>
                        <a href="#models">Models</a>
                    </li>
                    <li>
                        <a href="#views">Views</a>
                    </li>
                    <li>
                        <a href="#controllers">Controllers</a>
                    </li>
                    <li>
                        <a href="#view-models">View Models</a>
                    </li>
                    <li>
                        <a href="#modules">Modules</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="col-sm-8 col-sm-push-1">

            <h1 class='page header'>Octane</h1>
            <h2>Lightweight Application Development Framework</h2>

            <section id="why-octane">

                <h3>Why Octane</h3>

                <p>Octane was developed to provide a stepping stone into the world of frontend MVC (model-view-controller) frameworks and two-way data binding, without requiring developers to learn extensive and API-specific jargon. While there are methods
                    unique to Octane, the framework was built to keep those to a minimum, while at the same time using generic and descriptive language that should give the developer a good idea what a method does simply by its name. For the most part,
                    Octane strives to stay out of the way, allowing you to access its model and controller structures when you need them, and write code like you're used to everywhere else.</p>
                <p>Be aware: you'll probably write more code with Octane than with some other frameworks, but that's part of the idea. We don't obfuscate everything to the point it feels like magic when you use Octane's models and methods. We want developers
                    to still write javascript the way they want to, with the freedom to lean on Octane but not rely on it. At the same time, Octane's open ended-interface allows developers to add modules as they see fit, incorporating the core model/view/controller/view-model
                    system to accomplish their end goals. Ultimately, you're always writing your applications <em>your way</em>, not the Octane way</p>

            </section>

            <section id="overview">

                <h3>Overview</h3>
                <p>At its core, Octane is a model/view/controller/view-model (MVCVM) framework. The premise of any MV* framework is to compartmentalize different roles of an application code. Each component of an MV* have a specialized role, much like HTML,
                    CSS, and javascript have separate functions on the DOM. We'll break down each of Octane's <strong>model</strong>, <strong>view</strong>, <strong>controller</strong>, and <strong>view-model</strong> components in more detail further on,
                    but here's a brief overview for those new to MVC/MVCVM or who want to learn how Octane implements a the MV* design pattern.</p>

                <div class="bg-primary box-padded box-margined clearfix">

                    <h4>The Octane Circuit</h4>

                    <p>Octane's components are held together by the Circuit, a continuous loop of state monitoring, comparing, and updating that's triggered with any change to a data key bound between the <strong>View</strong> (DOM layer) and the <strong>Model</strong>.
                        This connection between the View and the Model is known as two-way data binding, and it's the most powerful weapon in an MV*'s arsenal. In Octane, this loop can be triggered in two ways, each from opposite ends of the Circuit:
                        one is in the <strong>View Model</strong>, whenever bound data is changed in the DOM by the user. This starts the Circuit's uptake channel, where data makes its way to the Model via the <strong>Controller</strong> and its methods.
                        The other trigger is inside the Model itself, fired when its data is altered. This initiates the Circuit's outflow channel as the updated data makes its way back to the DOM for the user to see.</p>

                </div>

                <div class="bg-info box-padded box-margined clearfix">

                    <h4 class="text-primary">Models</h4>

                    <p>Traditionally, a Model holds the data users see in your application. Static content is still held in HTML, but content that changes in the view depending on user interaction should be held in a Model. It provides a centralized location
                        for all data related to your application, or to a certain part of your application.</p>
                    <p>Octane's Models are unique in that they are partitioned into REST-style resource data that you set when you initiate the Model, and active data that changes depending on the user's interaction with your application. Resource data can
                        be accessed throughout your application in response to changes on input fields, select boxes, etc, but it cannot be edited. Active data, on the other hand, is entirely fluid and changes as users progress through the flow of the
                        application. The Resource data is by its nature stateless, while the active data is entirely mutable and comprises the state of your application. Throughout this documentation, <strong>active data</strong> and <strong>state data</strong> may
                        be used interchangeably to describe this dynamic data object in the Model.</p>
                    <a class="btn btn-info pull-right" href="#models" role="button">using Models</a>

                </div>

                <div class="bg-info box-padded box-margined clearfix">

                    <h4 class="text-primary">Views</h4>

                    <p>Views are the presentation layer, written in HTML and styled by CSS. In classic MV* implementaions, a view has no logic within it. In Octane, this is mostly true, however Octane creates is a <strong>View Object</strong> for every DOM
                        element you create with the <code>&lt;o-view&gt;</code> tag.</p>
                    <p>The View Object is has a very few methods, mostly to deal with animating itself in and out of the viewport. While Octane's <a href="#module-router">Router module</a> handles the logic for tasks like loading, unloading, and updating the
                        history, the View object holds information about how each particular view should adhere to those tasks. Think of the View as the HTML, and the View Object as reference to the HTML stored in the Router.</p>

                    <a class="btn btn-info pull-right" href="#views" role="button">writing Views</a>

                </div>

                <div class="bg-info box-padded box-margined clearfix">

                    <h4 class="text-primary">Controllers</h4>

                    <p>A Controller is the logic center of an MV* application. Whereas a Model holds application data, the Controller decides how that data is presented to the user. In Octane, the Controller also determines how data a user enters or chooses
                        is related to other data. For example, a user's input in the application can trigger changes in the Model state data beyond it's own key. Or dragging a slider on one part of the screen could prompt a change in another part, without
                        the two being explicitly tied to one another in the traditional manner. The funtionality implemented inside the controller is completely up to the developer, but we'll go into greater detail on where certain types of functionality
                        fit into the uptake and outflow channels of the Circuit.</p>

                    <a class="btn btn-info pull-right" href="#controllers" role="button">using Controllers</a>

                </div>

                <div class="bg-info box-padded box-margined clearfix">

                    <h4 class="text-primary">View Models</h4>
                    <p>A View Model in Octane is perhaps its primary departure from traditional MVC frameworks (hence the extra letters VM). The View Model has one job and one job only: to keep the data in the view in sync with the Model's state at all times.
                        This means when a user enters or selects information in the UI, the Model is updated instantly. Conversely, user-entered data is manipulated by the Controller in any way, or there's a change to other data points in the application,
                        the view reflects that newly altered data, again instantly.</p>

                    <p>In most cases, you won't need to interact with the View Model directly. It serves as an interface layer, performing its job silently in cooperation to your Controllers, Models, and Views.</p>

                    <a class="btn btn-info pull-right" href="#view-models" role="button">View Models</a>

                </div>

            </section>

            <section>
                <p o-model="myModel" o-update='{"text":"label1"}'></p>
                <input type="number" o-model="myModel" o-bind="input1" />

                <p o-model="myModel" o-update='{"text":"label2"}'></p>
                <input type="number" o-model="myModel" o-bind="input2" />

                <div class="progress">
                    <div o-model="myModel" o-update='{"style":"bar1","aria-valuenow":"input1"}' class="progress-bar progress-bar-warning progress-bar-striped active" role="progressbar" aria-valuenow=0 aria-valuemin=0 aria-valuemax=0 style="width: 0%">
                    </div>
                </div>

                <div class="progress">
                    <div o-model="myModel" o-update='{"style":"bar2","aria-valuenow":"input1"}' class="progress-bar progress-bar-warning progress-bar-striped active" role="progressbar" aria-valuenow=0 aria-valuemin=0 aria-valuemax=0 style="width: 0%">
                    </div>
                </div>

                <div class="progress">
                    <div o-model="myModel" o-update='{"style":"bar3","aria-valuenow":"input1"}' class="progress-bar progress-bar-warning progress-bar-striped active" role="progressbar" aria-valuenow=0 aria-valuemin=0 aria-valuemax=0 style="width: 0%">
                    </div>
                </div>


            </section>
        </div>
    </div>
    <script type="text/javascript" src="assets/js/_bower.js"></script>
    <script type="text/javascript" src="assets/js/doubleUnder.js"></script>
    <script type="text/javascript" src="assets/js/octane.js"></script>
    <script type="text/javascript" src="assets/js/debug.js"></script>
    <script type="text/javascript" src="assets/js/octane-views.js"></script>
    <script type="text/javascript" src="assets/js/router.js"></script>
    <script type="text/javascript" src="assets/js/startup_utilities.js"></script>
    <script type="text/javascript" src="assets/js/translator.js"></script>
    <script type="text/javascript" src="assets/js/view_animations.js"></script>
    <script type="text/javascript">
        Octane.init({
            name: 'API Documentation',
            Translator: [],
            Router: [{
                animations: Octane.lib('viewAnimations')
            }]
        });

        var myModel = $o.Model('myModel'),

            myController = $o.Controller(myModel)
                .audit('input1', 'number')
                .audit('input2', 'number')
                .hook('input1', {
                    'valid': function($dirty) {
                        $dirty.label1 = 'Great!';
                    },
                    'invalid': function($dirty) {
                        $dirty.label1 = 'Try Again...';
                    },
                    'undefined': function($dirty) {
                        $dirty.label1 = 'Please Enter a number.';
                    }
                })
                .hook('input2', {
                    'valid': function($dirty) {
                        $dirty.label2 = 'Great!';
                    },
                    'invalid': function($dirty) {
                        $dirty.label2 = 'Try Again...';
                    },
                    'undefined': function($dirty) {
                        $dirty.label2 = 'Please Enter a number.';
                    }
                })
                .parser('input1', function($dirty) {
                    $dirty.bar1 = width($dirty.input1 * 2);
                    $dirty.bar2 = width($dirty.input1 * 3);
                    $dirty.bar3 = width($dirty.input1 / 2);
                    return $dirty;
                })
                .parser('input2', function($dirty) {
                    $dirty.bar3 = width($dirty.input2 * 2);
                    $dirty.bar2 = width($dirty.input2 * 4);
                    $dirty.bar1 = width($dirty.input2 / 3);
                    return $dirty;
                });

        function width(num) {
            return 'width:' + num;
        }



        /* Octane API */


         // .errorLog()
         // .handle(event,handler)
         // .fire(event,data)
         // .getEvents()
         // .addModule(Constructor[,dependencies])
         // .Model(name,options)
         // .Controller(model)
         // .ViewModel(model,controller)
         // .getModels()
         // .getControllers()
         // .getviewModels()
         // .getViews()

         // .updateLoading(message,progress) 	    : extended from LoadingView Module
         // .removeLoading() 						: extended from LoadingView Module

         // .renderTranslator(langs[,container]) 	: extended from Translator Module
         // .translate([,data]) 						: extended from Translator Module
         // .getLang() 								: extended from Translator Module
         // .setLang(lang) 							: extended from Translator Module
         // .getLangContent(contentID) 				: extended from Translator Module
         // .setLangData(data) 						: extended from Translator Module

         // _proto_ .extend({})
         // _proto_ .define({property:value,...})

        /* Module methods */

         // _proto_ .inject(Module)

        /* Model methods */

         // setState({key:value,...})	
         // getState(stateKey)
         // access(resourceKey)

        /* Controller methods */


         // .addFitler(prop,filter)
         // .getFilters()
         // .applyFilters($data)

         // .addHook(prop,$caseObject)
         // .getHooks()
         // .applyHooks(data)

         // .addParser(prop,fn)
         // .getParsers()
         // .applyParsers($data)

         // .addTask(datakey,function(e.detail))
         // .getTasks()

        /* ViewModel methods */

         // .parse()
         // .refresh()
         // .respond()


         //
    </script>





</body>

</html>